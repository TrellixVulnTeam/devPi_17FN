#include <serialhandler.h>


// creates data structs for incoming data
IMUdata IMU;
GPSdata GPS;
GPSSYNC GPSSYNC;
NANOdata NANO;
ADPdata ADP;
THRUSTdata THR;

// creates union for typecasting
binaryfloat binfo;
binaryunsignedlong binul;

// creates instances of serial communication
serial::Serial IMUser(IMU_PORT,IMU_BAUD);
serial::Serial GPSser(GPS_PORT,GPS_BAUD);
serial::Serial NANOser(NANO_PORT,NANO_BAUD);
serial::Serial ADPser(ADP_PORT,ADP_BAUD);
serial::Serial THRser(THR_PORT,THR_BAUD);

int main(int argc, char const *argv[]) {
  if (!init()) {
    LOGinfo(1);
    return 0;
  }
  while (processbool) {
    if (checknewMSGdata()) {
      MSGparse();
    }
    if (IMUser.available() > 0) {
      IMUparse();
    }
    if (GPSser.available() > 20) {
      GPSparse();
    }
    if (NANOser.available() > 0) {
      NANOparse();
    }
    if (ADPser.available() > 0) {
      ADPparse();
    }
    if (THRser.available() > 0) {
      THRparse();
    }

  }
  return 0;
}

bool checknewMSGdata(void) {

  float check = *(float*)shmem_ptr_msg; //float pointed to by shared memory

  if (binfo.msg != check && (((int)check % 10 == 1) | ((int)check % 10 == 0))) { //compare sh.mem to current message status
    return true;
  }
  return false;
}

void MSGparse(void){ // receiver resets msg value to 999
  int MSGadress;
  int MSGcase;

  sem_wait(msg_sem);
  memcpy(&binfo.msg, shmem_ptr_msg, sizeof(binfo.msg)); // if no other process is acsessing sh.mem. copy msg flaot to lacal memory

  MSGadress = (int)binfo.msg % 1000; //separete message and message adressing e.g. 999000 to 999 and 000
  MSGcase = (int)binfo.msg / 1000; //for message adressing explanation see Bachelor Thesis. short version: first number indicates how many processes read msg. second number is the sender id and third number receiver id (1:serialhandler, 2:strapdown. 3: flightdatamanager, 0:all)

  switch (MSGcase) {
    case 999: binfo.msg = 999000; // standard msg value
      break;
    case 777: LOGbool = true; // received logging signal from Strapdowncalculation (Strapdown is initialized properly and user input confirmed logging start)
              LOGinfo(16);
              if (MSGadress == 320) {
                binfo.msg = 999000;
                memcpy(shmem_ptr_msg, &binfo.msg, sizeof(binfo.msg));
              }
              else{
                MSGadress += 100;
                binfo.msg = MSGcase * 1000 + MSGadress;
                memcpy(shmem_ptr_msg, &binfo.msg, sizeof(binfo.msg));
              }
      break;
    case 444: LOGinfo(15); //shutdowncall from StopCalculations process
              if (MSGadress == 300) {
                binfo.msg = 999000;
                memcpy(shmem_ptr_msg, &binfo.msg, sizeof(binfo.msg));
              }
              else{
                MSGadress += 100;
                binfo.msg = MSGcase * 1000 + MSGadress;
                memcpy(shmem_ptr_msg, &binfo.msg, sizeof(binfo.msg));
              }
              if (cleanup()) {
                LOGinfo(23);
                processbool = false;
              }

      break;
  }
  sem_post(msg_sem);
}

bool imudata(void){

  string Daten = "";
  bool endbool = false;

  if (imustartmatch[0] == 'b') { //if next byte (already readed by IMUparse function) equals second header data byte "b"
    imustartmatch = ""; //reset startmatch string
    endbool = false; //end of data stream

    while (!endbool) {
      Daten += IMUser.read(1); // read one byte
      if (Daten[Daten.size()-2] == 'e' && Daten[Daten.size()-1] == '/') { // check if last two read bytes match end of stream indicator "e/"
        char Datench[Daten.size() - 1]; //char array for data
        Daten.copy(Datench, Daten.size()-2, 0); // convert read data from string to char
        Datench[Daten.size()-2] = '\0'; // null terminated char array
        Daten = ""; // reset read String
        if ( (sizeof(Datench) / sizeof(Datench[0])) != DATA_PACKAGE_SIZE){ // check if char array matches the right size
          LOGinfo(6);
          return true;
        }
        memcpy(shmem_ptr_IMU, Datench, sizeof IMU); // copy char arry to shared memory space
        memcpy(&IMU, Datench, sizeof IMU); // copy char arry in local IMU struct
        if (LOGbool) { // if loging is enabled LOG data
          LOGIMUdata();
        }
        endbool = true; // successfully read data stream
      }
    }
    if (endbool == true) {
      return true;
    }
  }
  return false; // if second byte does not match second data stream header byte return false

}

bool imumessage(void){

  string Daten = "";
  bool endbool = false;

  if (imustartmatch[0] == 'm') { //if next byte (already readed by IMUparse function) equals second message data byte "m"
    imustartmatch = ""; // see imudata() for explenation of folowing
    endbool = false;
    while (!endbool) {
      Daten += IMUser.read(1);
      if (Daten[Daten.size()-2] == 'e' && Daten[Daten.size()-1] == '/') {
        char Datench[Daten.size() - 1];
        Daten.copy(Datench, Daten.size()-2, 0);
        Datench[Daten.size()-2] = '\0';
        Daten = "";
        if ( (sizeof(Datench) / sizeof(Datench[0])) != MESSAGE_PACKAGE_SIZE){
          LOGinfo(7);
          return false;
        }

        if (Datench[0] == 'a' && Datench[1] == 'a' && Datench[2] == 'a' && Datench[3] == 'a') { // check if read message is "sucessfull calibration of gyro" message from IMU
          binfo.msg = 888012; // send sucessfull calibration message to strapdown calculation
          sem_wait(msg_sem);
          memcpy(shmem_ptr_msg, &(binfo.msg), sizeof binfo.msg);
          sem_post(msg_sem);
          LOGinfo(9);
        }
        else if (!IMUsync) { // if IMU not timesynced to GPS UTC time, a message can only be IMU start up time
          for (size_t i = 0; i < 4; i++) {
            binul.binary[i] = Datench[i]; //cast binary message to unsigned long
          }
          IMU_sutime_ul = binul.ul; //safe start up time
          IMUsync = true; // IMu can be time synced
          }
        else if (!sentyaw){ // if IMU calibrated, message can only contain initialized Yaw value
          for (size_t i = 0; i < 4; i++) {
            binfo.binary[i] = Datench[i]; //cast binary to float
          }
          sem_wait(msg_sem);
          memcpy(shmem_ptr_msg, &(binfo.msg), sizeof binfo.msg); //send yaw value to Strapdown calculation
          sem_post(msg_sem);
          sentyaw = true;
        }
        endbool = true; // successfully read message stream
      }
    }
    return true;
  }
  return false; // if second byte neither matches second data stream header nor matches second message stream header byte return false
}

bool IMUparse(void){

  while (imustartmatch[0] != '*') { // aligns begin of incoming Serial stream to 1. header character "*"
    imustartmatch = "";
    IMUser.read(imustartmatch, 1); // reads 1 byte of serial stream
  }
  imustartmatch = "";
  IMUser.read(imustartmatch, 1); // read next byte
  if (imudata()) { // check if its a Data stream and parse it if true
    return true;
  }
  else{
    if (imumessage()) { // else its a Message stream
      return true;
    }
  }
  if ((imustartmatch[0] != 'b') | (imustartmatch[0] != 'm')) {
    LOGinfo(8);
  }
  return false;
}

bool nanodata(void){ // see IMU parse functions for explenation

  string Daten = "";
  bool endbool = false;

  if (nanostartmatch[0] == 'b') {
    nanostartmatch = "";
    endbool = false;

    while (!endbool) {
      Daten += NANOser.read(1);
      if (Daten[Daten.size()-2] == 'e' && Daten[Daten.size()-1] == '/') {
        char Datench[Daten.size() - 1];
        Daten.copy(Datench, Daten.size()-2, 0);
        Datench[Daten.size()-2] = '\0';
        Daten = "";

        if ( (sizeof(Datench) / sizeof(Datench[0])) != NANO_DATA_PACKAGE_SIZE){
          LOGinfo(19);
          return false;
        }
        memcpy(shmem_ptr_NANO, Datench, sizeof NANO); // copy char arry to shared memory space
        memcpy(&NANO, Datench, sizeof NANO);
        if (LOGbool) {
          LOGNANOdata();
        }
        endbool = true;
      }
    }
    if (endbool == true) {
      return true;
    }
  }
  return false;
}

bool nanomessage(void){ // see IMU parse functions for explenation

  string Daten = "";
  bool endbool = false;

  if (nanostartmatch[0] == 'm') {
    nanostartmatch = "";
    endbool = false;
    while (!endbool) {
      Daten += NANOser.read(1);
      if (Daten[Daten.size()-2] == 'e' && Daten[Daten.size()-1] == '/') {
        char Datench[Daten.size() - 1];
        Daten.copy(Datench, Daten.size()-2, 0);
        Datench[Daten.size()-2] = '\0';
        Daten = "";
        if ( (sizeof(Datench) / sizeof(Datench[0])) != NANO_MESSAGE_PACKAGE_SIZE){
          LOGinfo(20);
          return false;
        }
        if (!NANOsync) {
          for (size_t i = 0; i < 4; i++) {
            binul.binary[i] = Datench[i];
          }
          NANO_sutime_ul = binul.ul;
          NANOsync = true;
        }
        endbool = true;
      }
    }
    return true;
  }
  return false;
}

bool NANOparse(void){ // see IMU parse functions for explenation

  while (nanostartmatch[0] != '*') {
    nanostartmatch = "";
    NANOser.read(nanostartmatch, 1);
  }
  nanostartmatch = "";
  NANOser.read(nanostartmatch, 1);
  if (nanodata()) {
    return true;
  }
  else{
    if (nanomessage()) {
      return true;
    }
  }
  if ((nanostartmatch[0] != 'b') | (nanostartmatch[0] != 'm')) {
    LOGinfo(21);
  }
  return false;
}

bool adpdata(void){ // see IMU parse functions for explenation

  string Daten = "";
  bool endbool = false;

  if (adpstartmatch[0] == 'b') {
    adpstartmatch = "";
    endbool = false;

    while (!endbool) {
      Daten += ADPser.read(1);
      if (Daten[Daten.size()-2] == 'e' && Daten[Daten.size()-1] == '/') {
        char Datench[Daten.size() - 1];
        Daten.copy(Datench, Daten.size()-2, 0);
        Datench[Daten.size()-2] = '\0';
        Daten = "";

        if ( (sizeof(Datench) / sizeof(Datench[0])) != ADP_DATA_PACKAGE_SIZE){
          LOGinfo(24);
          return false;
        }
        memcpy(shmem_ptr_ADP, Datench, sizeof ADP); // copy char arry to shared memory space
        memcpy(&ADP, Datench, sizeof ADP);
        if (LOGbool) {
          LOGADPdata();
        }
        endbool = true;
      }
    }
    if (endbool == true) {
      return true;
    }
  }
  return false;

}

bool adpmessage(void){ // see IMU parse functions for explenation

  string Daten = "";
  bool endbool = false;

  if (adpstartmatch[0] == 'm') {
    adpstartmatch = "";
    endbool = false;
    while (!endbool) {
      Daten += ADPser.read(1);
      if (Daten[Daten.size()-2] == 'e' && Daten[Daten.size()-1] == '/') {
        char Datench[Daten.size() - 1];
        Daten.copy(Datench, Daten.size()-2, 0);
        Datench[Daten.size()-2] = '\0';
        Daten = "";
        if ( (sizeof(Datench) / sizeof(Datench[0])) != ADP_MESSAGE_PACKAGE_SIZE){
          LOGinfo(25);
          return false;
        }
        if (!ADPsync) {
          for (size_t i = 0; i < 4; i++) {
            binul.binary[i] = Datench[i];
          }
          ADP_sutime_ul = binul.ul;
          ADPsync = true;
        }
        endbool = true;
      }
    }
    return true;
  }
  return false;
}

bool ADPparse(void){ // see IMU parse functions for explenation

  while (adpstartmatch[0] != '*') {
    adpstartmatch = "";
    ADPser.read(adpstartmatch, 1);
  }
  adpstartmatch = "";
  ADPser.read(adpstartmatch, 1);
  if (adpdata()) {
    return true;
  }
  else{
    if (adpmessage()) {
      return true;
    }
  }
  if ((adpstartmatch[0] != 'b') | (adpstartmatch[0] != 'm')) {
    LOGinfo(26);
  }
  return false;
}

bool thrdata(void){ // see IMU parse functions for explenation

  string Daten = "";
  bool endbool = false;

  if (thrstartmatch[0] == 'b') {
    thrstartmatch = "";
    endbool = false;

    while (!endbool) {
      Daten += THRser.read(1);
      if (Daten[Daten.size()-2] == 'e' && Daten[Daten.size()-1] == '/') {
        char Datench[Daten.size() - 1];
        Daten.copy(Datench, Daten.size()-2, 0);
        Datench[Daten.size()-2] = '\0';
        Daten = "";

        if ( (sizeof(Datench) / sizeof(Datench[0])) != THR_DATA_PACKAGE_SIZE){
          LOGinfo(27);
          return false;
        }
        memcpy(shmem_ptr_THR, Datench, sizeof THR); // copy char arry to shared memory space
        memcpy(&THR, Datench, sizeof THR);
        if (LOGbool) {
          LOGTHRdata();
        }
        endbool = true;
      }
    }
    if (endbool == true) {
      return true;
    }
  }
  return false;

}

bool thrmessage(void){ // see IMU parse functions for explenation

  string Daten = "";
  bool endbool = false;

  if (thrstartmatch[0] == 'm') {
    thrstartmatch = "";
    endbool = false;
    while (!endbool) {
      Daten += THRser.read(1);
      if (Daten[Daten.size()-2] == 'e' && Daten[Daten.size()-1] == '/') {
        char Datench[Daten.size() - 1];
        Daten.copy(Datench, Daten.size()-2, 0);
        Datench[Daten.size()-2] = '\0';
        Daten = "";
        if ( (sizeof(Datench) / sizeof(Datench[0])) != THR_MESSAGE_PACKAGE_SIZE){
          LOGinfo(28);
          return false;
        }
        if (!THRsync) {
          for (size_t i = 0; i < 4; i++) {
            binul.binary[i] = Datench[i];
          }
          THR_sutime_ul = binul.ul;
          THRsync = true;
        }
        endbool = true;
      }
    }
    return true;
  }
  return false;
}

bool THRparse(void){ // see IMU parse functions for explenation

  while (thrstartmatch[0] != '*') {
    thrstartmatch = "";
    THRser.read(thrstartmatch, 1);
  }
  thrstartmatch = "";
  THRser.read(thrstartmatch, 1);
  if (thrdata()) {
    return true;
  }
  else{
    if (thrmessage()) {
      return true;
    }
  }
  if ((thrstartmatch[0] != 'b') | (thrstartmatch[0] != 'm')) {
    LOGinfo(29);
  }
  return false;
}

bool GPSparse(void){ // see IMU parse functions for explenation

  const unsigned char UBX_HEADER[] = { 0xB5, 0x62 };
  const unsigned char PVT_HEADER[] = {  0x01, 0x07 };
  const unsigned char SYNC_HEADER[] = { 0x0D, 0x03 };
  const unsigned char ACK_HEADER[] = { 0x05, 0x01 };
  const unsigned char NAK_HEADER[] = { 0x05, 0x00 };
  string Daten;
  string messagematch;
  bool endbool = false;

  while (gpsstartmatch[0] != UBX_HEADER[0]) {
    gpsstartmatch = "";
    GPSser.read(gpsstartmatch, 1);
  }
  gpsstartmatch = "";
  GPSser.read(gpsstartmatch, 1);
  if (gpsstartmatch[0] == UBX_HEADER[1]) {
    gpsstartmatch = "";
    endbool = false;
    GPSser.read(messagematch, 2);

    if (messagematch[0] == PVT_HEADER[0] && messagematch[1] == PVT_HEADER[1]) {
      Daten += messagematch;
      messagematch = "";
      while (!endbool) {
        Daten += GPSser.read(1);
        if (Daten.size() == PVT_PACKAGE_SIZE + 2) {
          char Datench[Daten.size() + 1];
          Daten.copy(Datench, Daten.size(), 0);
          Datench[Daten.size()] = '\0';
          Daten = "";
          if (!GpsChecksum(Datench,PVT_PACKAGE_SIZE + 2)) {
            return false;
          }
          memcpy(shmem_ptr_GPS, Datench + 4, sizeof(GPS));
          memcpy(&(GPS), Datench + 4, sizeof(GPS));
          if (LOGbool) {
            LOGGPSdata();
          }
          endbool = true;
        }
      }
    }
    if (messagematch[0] == SYNC_HEADER[0] && messagematch[1] == SYNC_HEADER[1]) {

      Daten += messagematch;
      messagematch = "";
      while (!endbool) {
        Daten += GPSser.read(1);
        if (Daten.size() == SYNC_PACKAGE_SIZE + 2) {
          char Datench[Daten.size() + 1];
          Daten.copy(Datench, Daten.size(), 0);
          Datench[Daten.size()] = '\0';
          Daten = "";

          if (!GpsChecksum(Datench,SYNC_PACKAGE_SIZE + 2)) {
            return false;
          }
          memcpy(&(GPSSYNC), Datench + 4, sizeof(GPSSYNC));
          GPSsync = true;
          endbool = true;
        }
      }
    }
    if (messagematch[0] == ACK_HEADER[0] && messagematch[1] == ACK_HEADER[1]){
      Daten += messagematch;
      messagematch = "";
      while (!endbool) {
        Daten += GPSser.read(1);
        if (Daten.size() == ACK_PACKAGE_SIZE + 2) {
          char Datench[Daten.size() + 1];
          Daten.copy(Datench, Daten.size(), 0);
          Datench[Daten.size()] = '\0';
          Daten = "";

          if (!GpsChecksum(Datench,ACK_PACKAGE_SIZE + 2)) {
            return false;
          }
          Ack = true;
          endbool = true;
        }
      }
    }
    if (messagematch[0] == NAK_HEADER[0] && messagematch[1] == NAK_HEADER[1]){
      Daten += messagematch;
      messagematch = "";
      while (!endbool) {
        Daten += GPSser.read(1);
        if (Daten.size() == NAK_PACKAGE_SIZE + 2) {
          char Datench[Daten.size() + 1];
          Daten.copy(Datench, Daten.size(), 0);
          Datench[Daten.size()] = '\0';
          Daten = "";

          if (!GpsChecksum(Datench,NAK_PACKAGE_SIZE + 2)) {
            return false;
          }
          Nak = true;
          endbool = true;
        }
      }
    }
  }
  return true;
}

string LOGname(const char* location, const char* prefix){
  int index = 0; //LOG index
  int filepresent;
  string name;
  for (size_t i = 0; i <= MAX_LOG_FILE; i++) { //check for first not existing Log file and creates it
    name = location; //build file path
    name += prefix;
    name += to_string(index);
    name += ".";
    name += LOG_SUFFIX;
    const char * namech = name.c_str(); //cast string to char
    filepresent = access(namech, F_OK);// check if present
    if (filepresent != 0) { //if not create file
      mode_t mode = S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH;
      open(namech, O_CREAT, mode);
      return name; //return file name as string
    }
    index++;
  }
  return 0;
}

void LOGIMUdata(void){
  ofstream file;
  int precision = 2;
  file.open(IMULOGfile, ios::out | ios::app);
  if (!file) {
    LOGinfo(2);
  }
  file << IMU.IMUtime << ";";
  for (size_t i = 0; i < 6; i++) {
    precision = 3; //  comma precision of loged file
    file << fixed << setprecision(precision) << IMU.variables[i] << ";";
  }
  file <<  endl;
  file.close();

  // char LOGbuffer[200];
  // unsigned int LOGbuffer_length;
  // int file;
  //
  // file = open(IMULOGfile.c_str(), O_WRONLY | O_APPEND );
  //
  // LOGbuffer_length = sprintf(LOGbuffer,"%lu;%.3f;%.3f;%.3f;%.3f;%.3f;%.3f\n", IMU.IMUtime, IMU.variables[0], IMU.variables[1], IMU.variables[2], IMU.variables[3], IMU.variables[4], IMU.variables[5]);
  // char LOGstring[LOGbuffer_length];
  // strncpy(LOGstring, LOGbuffer, LOGbuffer_length);
  // write(file, LOGstring, sizeof(LOGstring));
  // fsync(file);
  // close(file);
}

void LOGGPSdata(void){
  // ofstream file;
  //
  // file.open(GPSLOGfile, ios::out | ios::app);
  char LOGbuffer[200];
  unsigned int LOGbuffer_length;
  int file;

  file = open(GPSLOGfile.c_str(), O_WRONLY | O_APPEND );
  if (!file) {
    LOGinfo(2);
  }
  LOGbuffer_length = sprintf(LOGbuffer,"%lu;%hu;%d;%d;%d;%d;%d;%ld;%ld;%d;%d;%ld;%ld;%ld;%ld;%lu;%lu;%ld;%ld;%ld;%lu;%ld;%lu;%lu;%hu;%ld;%hu;%hu\n", GPS.iTOW, GPS.year, GPS.month, GPS.day, GPS.hour, GPS.min, GPS.sec, GPS.tAcc, GPS.nano, GPS.fixType, GPS.numSV, GPS.lon, GPS.lat, GPS.height, GPS.hMSL,GPS.hAcc, GPS.vAcc, GPS.velN, GPS.velE, GPS.velD, GPS.gSpeed, GPS.heading, GPS.sAcc, GPS.headingAcc, GPS.pDOP, GPS.headVeh, GPS.magDec, GPS.magAcc);
  char LOGstring[LOGbuffer_length];
  strncpy(LOGstring, LOGbuffer, LOGbuffer_length);
  write(file, LOGstring, sizeof(LOGstring));
  fsync(file);
  close(file);
  // file << GPS.iTOW << ";";
  // file << GPS.year << ";";
  // file << (int)GPS.month << ";";
  // file << (int)GPS.day << ";";
  // file << (int)GPS.hour << ";";
  // file << (int)GPS.min << ";";
  // file << (int)GPS.sec << ";";
  // file << GPS.tAcc << ";";
  // file << GPS.nano << ";";
  // file << (int)GPS.fixType << ";";
  // file << (int)GPS.numSV << ";";
  // file << GPS.lon << ";";
  // file << GPS.lat << ";";
  // file << GPS.height << ";";
  // file << GPS.hMSL << ";";
  // file << GPS.hAcc << ";";
  // file << GPS.vAcc << ";";
  // file << GPS.velN << ";";
  // file << GPS.velE << ";";
  // file << GPS.velD << ";";
  // file << GPS.gSpeed << ";";
  // file << GPS.heading << ";";
  // file << GPS.sAcc << ";";
  // file << GPS.headingAcc << ";";
  // file << GPS.pDOP << ";";
  // file << GPS.headVeh << ";";
  // file << GPS.magDec << ";";
  // file << GPS.magAcc << ";";
  //
  // file << endl;
  // file.close();
}

void LOGNANOdata(void){
  ofstream file;
  if (!file) {
    LOGinfo(2);
  }
  file.open(NANOLOGfile, ios::out | ios::app);
  file << NANO.NANOtime << ";";
  file << NANO.vdot << ";";
  file << NANO.vges << ";";
  for (size_t i = 0; i < NANO_PPM_CHANNELS; i++) {
   file << NANO.channelvalue[i] << ";";
  }
  file << endl;
  file.close();

  //char LOGbuffer[200];
  //unsigned int LOGbuffer_length;
  //int file;
  //file = open(NANOLOGfile.c_str(), O_WRONLY | O_APPEND );
  //if (!file) {
  //  LOGinfo(2);
  //}
  //LOGbuffer_length = sprintf(LOGbuffer,"%lu;%.3f;%.2f;%d;%d;%d;%d;%d;%d;%d;%d;%d;%d;%d;%d\n", NANO.NANOtime, NANO.vdot, NANO.vges,  NANO.channelvalue[0], NANO.channelvalue[1], NANO.channelvalue[2], NANO.channelvalue[3], NANO.channelvalue[4], NANO.channelvalue[5], NANO.channelvalue[6], NANO.channelvalue[7], NANO.channelvalue[8], NANO.channelvalue[9], NANO.channelvalue[10], NANO.channelvalue[11]);
  //char LOGstring[LOGbuffer_length];
  //strncpy(LOGstring, LOGbuffer, LOGbuffer_length);
  //write(file, LOGstring, sizeof(LOGstring));
  //fsync(file);
  //close(file);
}

void LOGADPdata(void){
  // ofstream file;
  // file.open(ADPLOGfile, ios::out | ios::app);
  char LOGbuffer[200];
  unsigned int LOGbuffer_length;
  int file;

  file = open(ADPLOGfile.c_str(), O_WRONLY | O_APPEND );
  if (!file) {
    LOGinfo(2);
  }
  // file << ADP.ADPtime << ";";
  // file << ADP.P_dyn << ";";
  // file << ADP.P_static << ";";
  // file << ADP.T << ";";
  // file << ADP.v << ";";
  // file << ADP.Alpha << ";";
  // file << ADP.Beta << ";";
  LOGbuffer_length = sprintf(LOGbuffer,"%lu;%.3f;%.3f\n", ADP.ADPtime, ADP.P_dyn, ADP.P_static);
  char LOGstring[LOGbuffer_length];
  strncpy(LOGstring, LOGbuffer, LOGbuffer_length);
  write(file, LOGstring, sizeof(LOGstring));
  fsync(file);
  close(file);

  // file << endl;
  // file.close();
}

void LOGTHRdata(void){

  ofstream file;
  // int precision = 2;
  file.open(THRLOGfile, ios::out | ios::app);
  if (!file) {
    LOGinfo(2);
  }
  file << THR.THRtime << ";";
  file << THR.temp1 << ";";
  file << THR.temp2 << ";";
  file << THR.force1 << ";";
  file << THR.force2 << ";";
  file << THR.raw1 << ";";
  file << THR.raw2 << ";";
  file << endl;
  file.close();

  // char LOGbuffer[200];
  // unsigned int LOGbuffer_length;
  // int file;
  // file = open(THRLOGfile.c_str(), O_WRONLY | O_APPEND );
  // LOGbuffer_length = sprintf(LOGbuffer,"%lu;%.3f;%.3f;%.3f;%.3f\n", THR.THRtime, THR.temp1, THR.temp2, THR.force1, THR.force2);
  // char LOGstring[LOGbuffer_length];
  // strncpy(LOGstring, LOGbuffer, LOGbuffer_length);
  // write(file, LOGstring, sizeof(LOGstring));
  // fsync(file);
  // close(file);
}

void* create_shared_mem(const int size, const char* name){
  int shmem_fd;
  shmem_fd = shm_open(name, O_CREAT | O_RDWR, 0666); //create sh.mem. in read an write mode and 0666 user access
  ftruncate(shmem_fd, size); //truncate it to right size
  return mmap(NULL, size, PROT_READ|PROT_WRITE,  MAP_SHARED, shmem_fd, 0); // map shared memory to sh.mem. pointer
}

bool sendtoGPS(const unsigned char send[], int size){
  bool feedback = false;
  Ack = false;
  Nak = false;

  int k = 0;
  while (!feedback) {
    for(int i = 0; i < size; i++) {
      if (GPSser.write(&send[i], 1) != 1) {
        return false;
      }
    }
    if (k > 5) {
      LOGinfo(22);
      return false;
    }
    int j = 0;
    while (!feedback) {
      if (GPSser.available() > 3) {
        if (!GPSparse()) {
          break;
        }
        if(Ack || Nak) {
          feedback = true;
        }
      }
      if (j > 20000) {
        break;
      }
      j += 1;
    }
    k += 1;
  }

  if (Ack) {
    return true;
  }
  if (Nak) {
    return false;
  }
  return false;
}

bool gpsinit(void){
  const unsigned char UBLOX_GGA0[] = {
  // Disable NMEA
  0xB5,0x62,0x06,0x01,0x08,0x00,0xF0,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x24, // GxGGA off
  // 0xB5,0x62,0x06,0x01,0x08,0x00,0xF0,0x01,0x00,0x00,0x00,0x00,0x00,0x01,0x01,0x2B, // GxGLL off
  // 0xB5,0x62,0x06,0x01,0x08,0x00,0xF0,0x02,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x32, // GxGSA off
  // 0xB5,0x62,0x06,0x01,0x08,0x00,0xF0,0x03,0x00,0x00,0x00,0x00,0x00,0x01,0x03,0x39, // GxGSV off
  // 0xB5,0x62,0x06,0x01,0x08,0x00,0xF0,0x04,0x00,0x00,0x00,0x00,0x00,0x01,0x04,0x40, // GxRMC off
  // 0xB5,0x62,0x06,0x01,0x08,0x00,0xF0,0x05,0x00,0x00,0x00,0x00,0x00,0x01,0x05,0x47, // GxVTG off
  // Disable UBX
  // 0xB5,0x62,0x06,0x01,0x08,0x00,0x0D,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x1F,0x20, //NAV-TIM-TIM2 Protocoll
  // 0xB5,0x62,0x06,0x01,0x08,0x00,0x01,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x17,0xDC, //NAV-PVT off
  // 0xB5,0x62,0x06,0x01,0x08,0x00,0x01,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x12,0xB9, //NAV-POSLLH off
  // 0xB5,0x62,0x06,0x01,0x08,0x00,0x01,0x21,0x00,0x00,0x00,0x00,0x00,0x00,0x31,0x92, //NAV-TIMEUTC off
  // 0xB5,0x62,0x06,0x01,0x08,0x00,0x01,0x12,0x00,0x00,0x00,0x00,0x00,0x00,0x22,0x29,  //NAV-VELNED off

  // Enable UBX
  // 0xB5,0x62,0x06,0x01,0x08,0x00,0x01,0x07,0x00,0x01,0x00,0x00,0x00,0x00,0x18,0xE1, //NAV-PVT on
  // 0xB5,0x62,0x06,0x01,0x08,0x00,0x01,0x02,0x00,0x01,0x00,0x00,0x00,0x00,0x13,0xBE, //NAV-POSLLH on
  // 0xB5,0x62,0x06,0x01,0x08,0x00,0x01,0x21,0x00,0x01,0x00,0x00,0x00,0x00,0x32,0x97, //NAV-TIMEUTC on
  // 0xB5,0x62,0x06,0x01,0x08,0x00,0x01,0x12,0x00,0x01,0x00,0x00,0x00,0x00,0x23,0x2E, //NAV-VELNED on

  // Rate
  // 0xB5,0x62,0x06,0x08,0x06,0x00,0x64,0x00,0x01,0x00,0x01,0x00,0x7A,0x12, //(10Hz)
  // 0xB5,0x62,0x06,0x08,0x06,0x00,0xC8,0x00,0x01,0x00,0x01,0x00,0xDE,0x6A, //(5Hz)
  // 0xB5,0x62,0x06,0x08,0x06,0x00,0xE8,0x03,0x01,0x00,0x01,0x00,0x01,0x39, //(1Hz)
  };
  const unsigned char UBLOX_GLL0[] = {
  // Disable NMEA
  // 0xB5,0x62,0x06,0x01,0x08,0x00,0xF0,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x24, // GxGGA off
  0xB5,0x62,0x06,0x01,0x08,0x00,0xF0,0x01,0x00,0x00,0x00,0x00,0x00,0x01,0x01,0x2B, // GxGLL off
  // 0xB5,0x62,0x06,0x01,0x08,0x00,0xF0,0x02,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x32, // GxGSA off
  // 0xB5,0x62,0x06,0x01,0x08,0x00,0xF0,0x03,0x00,0x00,0x00,0x00,0x00,0x01,0x03,0x39, // GxGSV off
  // 0xB5,0x62,0x06,0x01,0x08,0x00,0xF0,0x04,0x00,0x00,0x00,0x00,0x00,0x01,0x04,0x40, // GxRMC off
  // 0xB5,0x62,0x06,0x01,0x08,0x00,0xF0,0x05,0x00,0x00,0x00,0x00,0x00,0x01,0x05,0x47, // GxVTG off
  // Disable UBX
  // 0xB5,0x62,0x06,0x01,0x08,0x00,0x0D,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x1F,0x20, //NAV-TIM-TIM2 Protocoll
  // 0xB5,0x62,0x06,0x01,0x08,0x00,0x01,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x17,0xDC, //NAV-PVT off
  // 0xB5,0x62,0x06,0x01,0x08,0x00,0x01,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x12,0xB9, //NAV-POSLLH off
  // 0xB5,0x62,0x06,0x01,0x08,0x00,0x01,0x21,0x00,0x00,0x00,0x00,0x00,0x00,0x31,0x92, //NAV-TIMEUTC off
  // 0xB5,0x62,0x06,0x01,0x08,0x00,0x01,0x12,0x00,0x00,0x00,0x00,0x00,0x00,0x22,0x29,  //NAV-VELNED off

  // Enable UBX
  // 0xB5,0x62,0x06,0x01,0x08,0x00,0x01,0x07,0x00,0x01,0x00,0x00,0x00,0x00,0x18,0xE1, //NAV-PVT on
  // 0xB5,0x62,0x06,0x01,0x08,0x00,0x01,0x02,0x00,0x01,0x00,0x00,0x00,0x00,0x13,0xBE, //NAV-POSLLH on
  // 0xB5,0x62,0x06,0x01,0x08,0x00,0x01,0x21,0x00,0x01,0x00,0x00,0x00,0x00,0x32,0x97, //NAV-TIMEUTC on
  // 0xB5,0x62,0x06,0x01,0x08,0x00,0x01,0x12,0x00,0x01,0x00,0x00,0x00,0x00,0x23,0x2E, //NAV-VELNED on

  // Rate
  // 0xB5,0x62,0x06,0x08,0x06,0x00,0x64,0x00,0x01,0x00,0x01,0x00,0x7A,0x12, //(10Hz)
  // 0xB5,0x62,0x06,0x08,0x06,0x00,0xC8,0x00,0x01,0x00,0x01,0x00,0xDE,0x6A, //(5Hz)
  // 0xB5,0x62,0x06,0x08,0x06,0x00,0xE8,0x03,0x01,0x00,0x01,0x00,0x01,0x39, //(1Hz)
  };
  const unsigned char UBLOX_GSA0[] = {
  // Disable NMEA
  // 0xB5,0x62,0x06,0x01,0x08,0x00,0xF0,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x24, // GxGGA off
  // 0xB5,0x62,0x06,0x01,0x08,0x00,0xF0,0x01,0x00,0x00,0x00,0x00,0x00,0x01,0x01,0x2B, // GxGLL off
  0xB5,0x62,0x06,0x01,0x08,0x00,0xF0,0x02,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x32, // GxGSA off
  // 0xB5,0x62,0x06,0x01,0x08,0x00,0xF0,0x03,0x00,0x00,0x00,0x00,0x00,0x01,0x03,0x39, // GxGSV off
  // 0xB5,0x62,0x06,0x01,0x08,0x00,0xF0,0x04,0x00,0x00,0x00,0x00,0x00,0x01,0x04,0x40, // GxRMC off
  // 0xB5,0x62,0x06,0x01,0x08,0x00,0xF0,0x05,0x00,0x00,0x00,0x00,0x00,0x01,0x05,0x47, // GxVTG off
  // Disable UBX
  // 0xB5,0x62,0x06,0x01,0x08,0x00,0x0D,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x1F,0x20, //NAV-TIM-TIM2 Protocoll
  // 0xB5,0x62,0x06,0x01,0x08,0x00,0x01,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x17,0xDC, //NAV-PVT off
  // 0xB5,0x62,0x06,0x01,0x08,0x00,0x01,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x12,0xB9, //NAV-POSLLH off
  // 0xB5,0x62,0x06,0x01,0x08,0x00,0x01,0x21,0x00,0x00,0x00,0x00,0x00,0x00,0x31,0x92, //NAV-TIMEUTC off
  // 0xB5,0x62,0x06,0x01,0x08,0x00,0x01,0x12,0x00,0x00,0x00,0x00,0x00,0x00,0x22,0x29,  //NAV-VELNED off

  // Enable UBX
  // 0xB5,0x62,0x06,0x01,0x08,0x00,0x01,0x07,0x00,0x01,0x00,0x00,0x00,0x00,0x18,0xE1, //NAV-PVT on
  // 0xB5,0x62,0x06,0x01,0x08,0x00,0x01,0x02,0x00,0x01,0x00,0x00,0x00,0x00,0x13,0xBE, //NAV-POSLLH on
  // 0xB5,0x62,0x06,0x01,0x08,0x00,0x01,0x21,0x00,0x01,0x00,0x00,0x00,0x00,0x32,0x97, //NAV-TIMEUTC on
  // 0xB5,0x62,0x06,0x01,0x08,0x00,0x01,0x12,0x00,0x01,0x00,0x00,0x00,0x00,0x23,0x2E, //NAV-VELNED on

  // Rate
  // 0xB5,0x62,0x06,0x08,0x06,0x00,0x64,0x00,0x01,0x00,0x01,0x00,0x7A,0x12, //(10Hz)
  // 0xB5,0x62,0x06,0x08,0x06,0x00,0xC8,0x00,0x01,0x00,0x01,0x00,0xDE,0x6A, //(5Hz)
  // 0xB5,0x62,0x06,0x08,0x06,0x00,0xE8,0x03,0x01,0x00,0x01,0x00,0x01,0x39, //(1Hz)
  };
  const unsigned char UBLOX_GSV0[] = {
  // Disable NMEA
  // 0xB5,0x62,0x06,0x01,0x08,0x00,0xF0,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x24, // GxGGA off
  // 0xB5,0x62,0x06,0x01,0x08,0x00,0xF0,0x01,0x00,0x00,0x00,0x00,0x00,0x01,0x01,0x2B, // GxGLL off
  // 0xB5,0x62,0x06,0x01,0x08,0x00,0xF0,0x02,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x32, // GxGSA off
  0xB5,0x62,0x06,0x01,0x08,0x00,0xF0,0x03,0x00,0x00,0x00,0x00,0x00,0x01,0x03,0x39, // GxGSV off
  // 0xB5,0x62,0x06,0x01,0x08,0x00,0xF0,0x04,0x00,0x00,0x00,0x00,0x00,0x01,0x04,0x40, // GxRMC off
  // 0xB5,0x62,0x06,0x01,0x08,0x00,0xF0,0x05,0x00,0x00,0x00,0x00,0x00,0x01,0x05,0x47, // GxVTG off
  // Disable UBX
  // 0xB5,0x62,0x06,0x01,0x08,0x00,0x0D,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x1F,0x20, //NAV-TIM-TIM2 Protocoll
  // 0xB5,0x62,0x06,0x01,0x08,0x00,0x01,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x17,0xDC, //NAV-PVT off
  // 0xB5,0x62,0x06,0x01,0x08,0x00,0x01,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x12,0xB9, //NAV-POSLLH off
  // 0xB5,0x62,0x06,0x01,0x08,0x00,0x01,0x21,0x00,0x00,0x00,0x00,0x00,0x00,0x31,0x92, //NAV-TIMEUTC off
  // 0xB5,0x62,0x06,0x01,0x08,0x00,0x01,0x12,0x00,0x00,0x00,0x00,0x00,0x00,0x22,0x29,  //NAV-VELNED off

  // Enable UBX
  // 0xB5,0x62,0x06,0x01,0x08,0x00,0x01,0x07,0x00,0x01,0x00,0x00,0x00,0x00,0x18,0xE1, //NAV-PVT on
  // 0xB5,0x62,0x06,0x01,0x08,0x00,0x01,0x02,0x00,0x01,0x00,0x00,0x00,0x00,0x13,0xBE, //NAV-POSLLH on
  // 0xB5,0x62,0x06,0x01,0x08,0x00,0x01,0x21,0x00,0x01,0x00,0x00,0x00,0x00,0x32,0x97, //NAV-TIMEUTC on
  // 0xB5,0x62,0x06,0x01,0x08,0x00,0x01,0x12,0x00,0x01,0x00,0x00,0x00,0x00,0x23,0x2E, //NAV-VELNED on

  // Rate
  // 0xB5,0x62,0x06,0x08,0x06,0x00,0x64,0x00,0x01,0x00,0x01,0x00,0x7A,0x12, //(10Hz)
  // 0xB5,0x62,0x06,0x08,0x06,0x00,0xC8,0x00,0x01,0x00,0x01,0x00,0xDE,0x6A, //(5Hz)
  // 0xB5,0x62,0x06,0x08,0x06,0x00,0xE8,0x03,0x01,0x00,0x01,0x00,0x01,0x39, //(1Hz)
  };
  const unsigned char UBLOX_RMC0[] = {
  // Disable NMEA
  // 0xB5,0x62,0x06,0x01,0x08,0x00,0xF0,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x24, // GxGGA off
  // 0xB5,0x62,0x06,0x01,0x08,0x00,0xF0,0x01,0x00,0x00,0x00,0x00,0x00,0x01,0x01,0x2B, // GxGLL off
  // 0xB5,0x62,0x06,0x01,0x08,0x00,0xF0,0x02,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x32, // GxGSA off
  // 0xB5,0x62,0x06,0x01,0x08,0x00,0xF0,0x03,0x00,0x00,0x00,0x00,0x00,0x01,0x03,0x39, // GxGSV off
  0xB5,0x62,0x06,0x01,0x08,0x00,0xF0,0x04,0x00,0x00,0x00,0x00,0x00,0x01,0x04,0x40, // GxRMC off
  // 0xB5,0x62,0x06,0x01,0x08,0x00,0xF0,0x05,0x00,0x00,0x00,0x00,0x00,0x01,0x05,0x47, // GxVTG off
  // Disable UBX
  // 0xB5,0x62,0x06,0x01,0x08,0x00,0x0D,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x1F,0x20, //NAV-TIM-TIM2 Protocoll
  // 0xB5,0x62,0x06,0x01,0x08,0x00,0x01,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x17,0xDC, //NAV-PVT off
  // 0xB5,0x62,0x06,0x01,0x08,0x00,0x01,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x12,0xB9, //NAV-POSLLH off
  // 0xB5,0x62,0x06,0x01,0x08,0x00,0x01,0x21,0x00,0x00,0x00,0x00,0x00,0x00,0x31,0x92, //NAV-TIMEUTC off
  // 0xB5,0x62,0x06,0x01,0x08,0x00,0x01,0x12,0x00,0x00,0x00,0x00,0x00,0x00,0x22,0x29,  //NAV-VELNED off

  // Enable UBX
  // 0xB5,0x62,0x06,0x01,0x08,0x00,0x01,0x07,0x00,0x01,0x00,0x00,0x00,0x00,0x18,0xE1, //NAV-PVT on
  // 0xB5,0x62,0x06,0x01,0x08,0x00,0x01,0x02,0x00,0x01,0x00,0x00,0x00,0x00,0x13,0xBE, //NAV-POSLLH on
  // 0xB5,0x62,0x06,0x01,0x08,0x00,0x01,0x21,0x00,0x01,0x00,0x00,0x00,0x00,0x32,0x97, //NAV-TIMEUTC on
  // 0xB5,0x62,0x06,0x01,0x08,0x00,0x01,0x12,0x00,0x01,0x00,0x00,0x00,0x00,0x23,0x2E, //NAV-VELNED on

  // Rate
  // 0xB5,0x62,0x06,0x08,0x06,0x00,0x64,0x00,0x01,0x00,0x01,0x00,0x7A,0x12, //(10Hz)
  // 0xB5,0x62,0x06,0x08,0x06,0x00,0xC8,0x00,0x01,0x00,0x01,0x00,0xDE,0x6A, //(5Hz)
  // 0xB5,0x62,0x06,0x08,0x06,0x00,0xE8,0x03,0x01,0x00,0x01,0x00,0x01,0x39, //(1Hz)
  };
  const unsigned char UBLOX_VTG0[] = {
  // Disable NMEA
  // 0xB5,0x62,0x06,0x01,0x08,0x00,0xF0,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x24, // GxGGA off
  // 0xB5,0x62,0x06,0x01,0x08,0x00,0xF0,0x01,0x00,0x00,0x00,0x00,0x00,0x01,0x01,0x2B, // GxGLL off
  // 0xB5,0x62,0x06,0x01,0x08,0x00,0xF0,0x02,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x32, // GxGSA off
  // 0xB5,0x62,0x06,0x01,0x08,0x00,0xF0,0x03,0x00,0x00,0x00,0x00,0x00,0x01,0x03,0x39, // GxGSV off
  // 0xB5,0x62,0x06,0x01,0x08,0x00,0xF0,0x04,0x00,0x00,0x00,0x00,0x00,0x01,0x04,0x40, // GxRMC off
  0xB5,0x62,0x06,0x01,0x08,0x00,0xF0,0x05,0x00,0x00,0x00,0x00,0x00,0x01,0x05,0x47, // GxVTG off
  // Disable UBX
  // 0xB5,0x62,0x06,0x01,0x08,0x00,0x0D,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x1F,0x20, //NAV-TIM-TIM2 Protocoll
  // 0xB5,0x62,0x06,0x01,0x08,0x00,0x01,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x17,0xDC, //NAV-PVT off
  // 0xB5,0x62,0x06,0x01,0x08,0x00,0x01,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x12,0xB9, //NAV-POSLLH off
  // 0xB5,0x62,0x06,0x01,0x08,0x00,0x01,0x21,0x00,0x00,0x00,0x00,0x00,0x00,0x31,0x92, //NAV-TIMEUTC off
  // 0xB5,0x62,0x06,0x01,0x08,0x00,0x01,0x12,0x00,0x00,0x00,0x00,0x00,0x00,0x22,0x29,  //NAV-VELNED off

  // Enable UBX
  // 0xB5,0x62,0x06,0x01,0x08,0x00,0x01,0x07,0x00,0x01,0x00,0x00,0x00,0x00,0x18,0xE1, //NAV-PVT on
  // 0xB5,0x62,0x06,0x01,0x08,0x00,0x01,0x02,0x00,0x01,0x00,0x00,0x00,0x00,0x13,0xBE, //NAV-POSLLH on
  // 0xB5,0x62,0x06,0x01,0x08,0x00,0x01,0x21,0x00,0x01,0x00,0x00,0x00,0x00,0x32,0x97, //NAV-TIMEUTC on
  // 0xB5,0x62,0x06,0x01,0x08,0x00,0x01,0x12,0x00,0x01,0x00,0x00,0x00,0x00,0x23,0x2E, //NAV-VELNED on

  // Rate
  // 0xB5,0x62,0x06,0x08,0x06,0x00,0x64,0x00,0x01,0x00,0x01,0x00,0x7A,0x12, //(10Hz)
  // 0xB5,0x62,0x06,0x08,0x06,0x00,0xC8,0x00,0x01,0x00,0x01,0x00,0xDE,0x6A, //(5Hz)
  // 0xB5,0x62,0x06,0x08,0x06,0x00,0xE8,0x03,0x01,0x00,0x01,0x00,0x01,0x39, //(1Hz)
  };
  const unsigned char UBLOX_10HZ[] = {
  // Disable NMEA
  // 0xB5,0x62,0x06,0x01,0x08,0x00,0xF0,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x24, // GxGGA off
  // 0xB5,0x62,0x06,0x01,0x08,0x00,0xF0,0x01,0x00,0x00,0x00,0x00,0x00,0x01,0x01,0x2B, // GxGLL off
  // 0xB5,0x62,0x06,0x01,0x08,0x00,0xF0,0x02,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x32, // GxGSA off
  // 0xB5,0x62,0x06,0x01,0x08,0x00,0xF0,0x03,0x00,0x00,0x00,0x00,0x00,0x01,0x03,0x39, // GxGSV off
  // 0xB5,0x62,0x06,0x01,0x08,0x00,0xF0,0x04,0x00,0x00,0x00,0x00,0x00,0x01,0x04,0x40, // GxRMC off
  // 0xB5,0x62,0x06,0x01,0x08,0x00,0xF0,0x05,0x00,0x00,0x00,0x00,0x00,0x01,0x05,0x47, // GxVTG off
  // Disable UBX
  // 0xB5,0x62,0x06,0x01,0x08,0x00,0x0D,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x1F,0x20, //NAV-TIM-TIM2 Protocoll
  // 0xB5,0x62,0x06,0x01,0x08,0x00,0x01,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x17,0xDC, //NAV-PVT off
  // 0xB5,0x62,0x06,0x01,0x08,0x00,0x01,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x12,0xB9, //NAV-POSLLH off
  // 0xB5,0x62,0x06,0x01,0x08,0x00,0x01,0x21,0x00,0x00,0x00,0x00,0x00,0x00,0x31,0x92, //NAV-TIMEUTC off
  // 0xB5,0x62,0x06,0x01,0x08,0x00,0x01,0x12,0x00,0x00,0x00,0x00,0x00,0x00,0x22,0x29,  //NAV-VELNED off

  // Enable UBX
  // 0xB5,0x62,0x06,0x01,0x08,0x00,0x01,0x07,0x00,0x01,0x00,0x00,0x00,0x00,0x18,0xE1, //NAV-PVT on
  // 0xB5,0x62,0x06,0x01,0x08,0x00,0x01,0x02,0x00,0x01,0x00,0x00,0x00,0x00,0x13,0xBE, //NAV-POSLLH on
  // 0xB5,0x62,0x06,0x01,0x08,0x00,0x01,0x21,0x00,0x01,0x00,0x00,0x00,0x00,0x32,0x97, //NAV-TIMEUTC on
  // 0xB5,0x62,0x06,0x01,0x08,0x00,0x01,0x12,0x00,0x01,0x00,0x00,0x00,0x00,0x23,0x2E, //NAV-VELNED on

  // Rate
  0xB5,0x62,0x06,0x08,0x06,0x00,0x64,0x00,0x01,0x00,0x01,0x00,0x7A,0x12, //(10Hz)
  // 0xB5,0x62,0x06,0x08,0x06,0x00,0xC8,0x00,0x01,0x00,0x01,0x00,0xDE,0x6A, //(5Hz)
  // 0xB5,0x62,0x06,0x08,0x06,0x00,0xE8,0x03,0x01,0x00,0x01,0x00,0x01,0x39, //(1Hz)
  };
  const unsigned char UBLOX_PVT1[] = {
  // Disable NMEA
  // 0xB5,0x62,0x06,0x01,0x08,0x00,0xF0,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x24, // GxGGA off
  // 0xB5,0x62,0x06,0x01,0x08,0x00,0xF0,0x01,0x00,0x00,0x00,0x00,0x00,0x01,0x01,0x2B, // GxGLL off
  // 0xB5,0x62,0x06,0x01,0x08,0x00,0xF0,0x02,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x32, // GxGSA off
  // 0xB5,0x62,0x06,0x01,0x08,0x00,0xF0,0x03,0x00,0x00,0x00,0x00,0x00,0x01,0x03,0x39, // GxGSV off
  // 0xB5,0x62,0x06,0x01,0x08,0x00,0xF0,0x04,0x00,0x00,0x00,0x00,0x00,0x01,0x04,0x40, // GxRMC off
  // 0xB5,0x62,0x06,0x01,0x08,0x00,0xF0,0x05,0x00,0x00,0x00,0x00,0x00,0x01,0x05,0x47, // GxVTG off
  // Disable UBX
  // 0xB5,0x62,0x06,0x01,0x08,0x00,0x0D,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x1F,0x20, //NAV-TIM-TIM2 Protocoll
  // 0xB5,0x62,0x06,0x01,0x08,0x00,0x01,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x17,0xDC, //NAV-PVT off
  // 0xB5,0x62,0x06,0x01,0x08,0x00,0x01,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x12,0xB9, //NAV-POSLLH off
  // 0xB5,0x62,0x06,0x01,0x08,0x00,0x01,0x21,0x00,0x00,0x00,0x00,0x00,0x00,0x31,0x92, //NAV-TIMEUTC off
  // 0xB5,0x62,0x06,0x01,0x08,0x00,0x01,0x12,0x00,0x00,0x00,0x00,0x00,0x00,0x22,0x29,  //NAV-VELNED off

  // Enable UBX
  0xB5,0x62,0x06,0x01,0x08,0x00,0x01,0x07,0x00,0x01,0x00,0x00,0x00,0x00,0x18,0xE1, //NAV-PVT on
  // 0xB5,0x62,0x06,0x01,0x08,0x00,0x01,0x02,0x00,0x01,0x00,0x00,0x00,0x00,0x13,0xBE, //NAV-POSLLH on
  // 0xB5,0x62,0x06,0x01,0x08,0x00,0x01,0x21,0x00,0x01,0x00,0x00,0x00,0x00,0x32,0x97, //NAV-TIMEUTC on
  // 0xB5,0x62,0x06,0x01,0x08,0x00,0x01,0x12,0x00,0x01,0x00,0x00,0x00,0x00,0x23,0x2E, //NAV-VELNED on

  // Rate
  0xB5,0x62,0x06,0x08,0x06,0x00,0x64,0x00,0x01,0x00,0x01,0x00,0x7A,0x12, //(10Hz)
  // 0xB5,0x62,0x06,0x08,0x06,0x00,0xC8,0x00,0x01,0x00,0x01,0x00,0xDE,0x6A, //(5Hz)
  // 0xB5,0x62,0x06,0x08,0x06,0x00,0xE8,0x03,0x01,0x00,0x01,0x00,0x01,0x39, //(1Hz)
  };

  if (!sendtoGPS(UBLOX_GGA0, sizeof(UBLOX_GGA0))) {
    return false;
  }
  if (!sendtoGPS(UBLOX_GLL0, sizeof(UBLOX_GLL0))) {
    return false;
  }
  if (!sendtoGPS(UBLOX_GSA0, sizeof(UBLOX_GSA0))) {
    return false;
  }
  if (!sendtoGPS(UBLOX_GSV0, sizeof(UBLOX_GSV0))) {
    return false;
  }
  if (!sendtoGPS(UBLOX_RMC0, sizeof(UBLOX_RMC0))) {
    return false;
  }
  if (!sendtoGPS(UBLOX_VTG0, sizeof(UBLOX_VTG0))) {
    return false;
  }
  if (!sendtoGPS(UBLOX_10HZ, sizeof(UBLOX_10HZ))) {
    return false;
  }
  if (!sendtoGPS(UBLOX_PVT1, sizeof(UBLOX_PVT1))) {
    return false;
  }

 return true;
}

bool GpsChecksum(char* Datench, int size){

  static unsigned char checksum[2];
  memset(&checksum, 0, 2);

  for (int i = 0; i < size - 2; i++) {
    checksum[0] += Datench[i];
    checksum[1] += checksum[0];
  }

  if (checksum[0] == Datench[size-2] && checksum[1] == Datench[size-1]) {
    return true;

  }
  return false;
}

void syncIMU(void){
  LOGinfo(13);
  IMUser.write("S");
  tIMU = std::chrono::high_resolution_clock::now();
  while (!IMUsync){
    if (IMUser.available() > 0) {
      IMUparse();
    }
  }
}

void syncNANO(void){
  LOGinfo(18);
  usleep(2000000); // evtl. wegmachen wegen GPS valid solution while loop
  NANOser.write("S");
  tNANO = std::chrono::high_resolution_clock::now();
  while (!NANOsync){
    if (NANOser.available() > 0) {
      NANOparse();
    }
  }
}

void syncADP(void){
  LOGinfo(30);
  ADPser.write("S");
  tADP = std::chrono::high_resolution_clock::now();
  while (!ADPsync){
    if (ADPser.available() > 0) {
      ADPparse();
    }
  }
}

void syncTHR(void){
  LOGinfo(31);
  THRser.write("S");
  tTHR = std::chrono::high_resolution_clock::now();
  while (!THRsync){
    if (THRser.available() > 0) {
      THRparse();
    }
  }
}

void syncGPS(void) {
  wiringPiSetup();
  pinMode(INTERUPT_PIN, OUTPUT);

  const unsigned char UBLOX_TIM1[] = {
    // Disable NMEA
    // 0xB5,0x62,0x06,0x01,0x08,0x00,0xF0,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x24, // GxGGA off
    // 0xB5,0x62,0x06,0x01,0x08,0x00,0xF0,0x01,0x00,0x00,0x00,0x00,0x00,0x01,0x01,0x2B, // GxGLL off
    // 0xB5,0x62,0x06,0x01,0x08,0x00,0xF0,0x02,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x32, // GxGSA off
    // 0xB5,0x62,0x06,0x01,0x08,0x00,0xF0,0x03,0x00,0x00,0x00,0x00,0x00,0x01,0x03,0x39, // GxGSV off
    // 0xB5,0x62,0x06,0x01,0x08,0x00,0xF0,0x04,0x00,0x00,0x00,0x00,0x00,0x01,0x04,0x40, // GxRMC off
    // 0xB5,0x62,0x06,0x01,0x08,0x00,0xF0,0x05,0x00,0x00,0x00,0x00,0x00,0x01,0x05,0x47, // GxVTG off
    // Disable UBX
    // 0xB5,0x62,0x06,0x01,0x08,0x00,0x01,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x17,0xDC, //NAV-PVT off
    // 0xB5,0x62,0x06,0x01,0x08,0x00,0x01,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x12,0xB9, //NAV-POSLLH off
    // 0xB5,0x62,0x06,0x01,0x08,0x00,0x01,0x21,0x00,0x00,0x00,0x00,0x00,0x00,0x31,0x92, //NAV-TIMEUTC off
    // 0xB5,0x62,0x06,0x01,0x08,0x00,0x01,0x12,0x00,0x00,0x00,0x00,0x00,0x00,0x22,0x29,  //NAV-VELNED off

    0xB5,0x62,0x06,0x01,0x08,0x00,0x0D,0x03,0x00,0x01,0x00,0x00,0x00,0x00,0x20,0x25, //NAV-TIM-TIM2 Protocoll
    // 0xB5,0x62,0x0D,0x03,0x00,0x00,0x1F,0x20, //Poll NAV-TIM-TIM2

    // Rate
    // 0xB5,0x62,0x06,0x08,0x06,0x00,0x64,0x00,0x01,0x00,0x01,0x00,0x7A,0x12, //(10Hz)
  };
  const unsigned char UBLOX_PVT0[] = {
    // Disable NMEA
    // 0xB5,0x62,0x06,0x01,0x08,0x00,0xF0,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x24, // GxGGA off
    // 0xB5,0x62,0x06,0x01,0x08,0x00,0xF0,0x01,0x00,0x00,0x00,0x00,0x00,0x01,0x01,0x2B, // GxGLL off
    // 0xB5,0x62,0x06,0x01,0x08,0x00,0xF0,0x02,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x32, // GxGSA off
    // 0xB5,0x62,0x06,0x01,0x08,0x00,0xF0,0x03,0x00,0x00,0x00,0x00,0x00,0x01,0x03,0x39, // GxGSV off
    // 0xB5,0x62,0x06,0x01,0x08,0x00,0xF0,0x04,0x00,0x00,0x00,0x00,0x00,0x01,0x04,0x40, // GxRMC off
    // 0xB5,0x62,0x06,0x01,0x08,0x00,0xF0,0x05,0x00,0x00,0x00,0x00,0x00,0x01,0x05,0x47, // GxVTG off
    // Disable UBX
    0xB5,0x62,0x06,0x01,0x08,0x00,0x01,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x17,0xDC, //NAV-PVT off
    // 0xB5,0x62,0x06,0x01,0x08,0x00,0x01,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x12,0xB9, //NAV-POSLLH off
    // 0xB5,0x62,0x06,0x01,0x08,0x00,0x01,0x21,0x00,0x00,0x00,0x00,0x00,0x00,0x31,0x92, //NAV-TIMEUTC off
    // 0xB5,0x62,0x06,0x01,0x08,0x00,0x01,0x12,0x00,0x00,0x00,0x00,0x00,0x00,0x22,0x29,  //NAV-VELNED off

    // 0xB5,0x62,0x06,0x01,0x08,0x00,0x0D,0x03,0x00,0x01,0x00,0x00,0x00,0x00,0x20,0x25, //NAV-TIM-TIM2 Protocoll
    // 0xB5,0x62,0x0D,0x03,0x00,0x00,0x1F,0x20, //Poll NAV-TIM-TIM2

    // Rate
    // 0xB5,0x62,0x06,0x08,0x06,0x00,0x64,0x00,0x01,0x00,0x01,0x00,0x7A,0x12, //(10Hz)
  };
  const unsigned char UBLOX_TIM0[] = {
    // Disable NMEA
    // 0xB5,0x62,0x06,0x01,0x08,0x00,0xF0,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x24, // GxGGA off
    // 0xB5,0x62,0x06,0x01,0x08,0x00,0xF0,0x01,0x00,0x00,0x00,0x00,0x00,0x01,0x01,0x2B, // GxGLL off
    // 0xB5,0x62,0x06,0x01,0x08,0x00,0xF0,0x02,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x32, // GxGSA off
    // 0xB5,0x62,0x06,0x01,0x08,0x00,0xF0,0x03,0x00,0x00,0x00,0x00,0x00,0x01,0x03,0x39, // GxGSV off
    // 0xB5,0x62,0x06,0x01,0x08,0x00,0xF0,0x04,0x00,0x00,0x00,0x00,0x00,0x01,0x04,0x40, // GxRMC off
    // 0xB5,0x62,0x06,0x01,0x08,0x00,0xF0,0x05,0x00,0x00,0x00,0x00,0x00,0x01,0x05,0x47, // GxVTG off
    // Disable UBX
    // 0xB5,0x62,0x06,0x01,0x08,0x00,0x01,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x12,0xB9, //NAV-POSLLH off
    // 0xB5,0x62,0x06,0x01,0x08,0x00,0x01,0x21,0x00,0x00,0x00,0x00,0x00,0x00,0x31,0x92, //NAV-TIMEUTC off
    // 0xB5,0x62,0x06,0x01,0x08,0x00,0x01,0x12,0x00,0x00,0x00,0x00,0x00,0x00,0x22,0x29,  //NAV-VELNED off
    0xB5,0x62,0x06,0x01,0x08,0x00,0x0D,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x1F,0x20, //NAV-TIM-TIM2 Protocoll

    // Enable UBX
    // 0xB5,0x62,0x06,0x01,0x08,0x00,0x01,0x07,0x00,0x01,0x00,0x00,0x00,0x00,0x18,0xE1, //NAV-PVT on

    // Rate
    // 0xB5,0x62,0x06,0x08,0x06,0x00,0x64,0x00,0x01,0x00,0x01,0x00,0x7A,0x12, //(10Hz)
  };
  const unsigned char UBLOX_PVT1[] = {
    // Disable NMEA
    // 0xB5,0x62,0x06,0x01,0x08,0x00,0xF0,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x24, // GxGGA off
    // 0xB5,0x62,0x06,0x01,0x08,0x00,0xF0,0x01,0x00,0x00,0x00,0x00,0x00,0x01,0x01,0x2B, // GxGLL off
    // 0xB5,0x62,0x06,0x01,0x08,0x00,0xF0,0x02,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x32, // GxGSA off
    // 0xB5,0x62,0x06,0x01,0x08,0x00,0xF0,0x03,0x00,0x00,0x00,0x00,0x00,0x01,0x03,0x39, // GxGSV off
    // 0xB5,0x62,0x06,0x01,0x08,0x00,0xF0,0x04,0x00,0x00,0x00,0x00,0x00,0x01,0x04,0x40, // GxRMC off
    // 0xB5,0x62,0x06,0x01,0x08,0x00,0xF0,0x05,0x00,0x00,0x00,0x00,0x00,0x01,0x05,0x47, // GxVTG off
    // Disable UBX
    // 0xB5,0x62,0x06,0x01,0x08,0x00,0x01,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x12,0xB9, //NAV-POSLLH off
    // 0xB5,0x62,0x06,0x01,0x08,0x00,0x01,0x21,0x00,0x00,0x00,0x00,0x00,0x00,0x31,0x92, //NAV-TIMEUTC off
    // 0xB5,0x62,0x06,0x01,0x08,0x00,0x01,0x12,0x00,0x00,0x00,0x00,0x00,0x00,0x22,0x29,  //NAV-VELNED off
    // 0xB5,0x62,0x06,0x01,0x08,0x00,0x0D,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x1F,0x20, //NAV-TIM-TIM2 Protocoll

    // Enable UBX
    0xB5,0x62,0x06,0x01,0x08,0x00,0x01,0x07,0x00,0x01,0x00,0x00,0x00,0x00,0x18,0xE1, //NAV-PVT on

    // Rate
    // 0xB5,0x62,0x06,0x08,0x06,0x00,0x64,0x00,0x01,0x00,0x01,0x00,0x7A,0x12, //(10Hz)
  };

  sendtoGPS(UBLOX_TIM1, sizeof(UBLOX_TIM1));
  sendtoGPS(UBLOX_PVT0, sizeof(UBLOX_PVT0));

  digitalWrite(INTERUPT_PIN, 1);
  tGPS = std::chrono::high_resolution_clock::now();
  digitalWrite(INTERUPT_PIN, 0);
  while (!GPSsync) {
    if (GPSser.available() > 4) {
      GPSparse();
    }
  }

  sendtoGPS(UBLOX_TIM0, sizeof(UBLOX_TIM0));
  sendtoGPS(UBLOX_PVT1, sizeof(UBLOX_PVT1));
}

void sync(void){
  cout << "sync begin" << endl;
  double measurementtimeshift;
  syncIMU();
  cout << "IMU synced" << endl;
  syncNANO();
  cout << "Nano synced" << endl;
  syncADP();
  cout << "ADP synced" << endl;
  syncTHR();
  cout << "THR synced" << endl;
  syncGPS();
  cout << "GPS synced" << endl;
  IMU_sutime = (double)IMU_sutime_ul;
  NANO_sutime = (double)NANO_sutime_ul;
  ADP_sutime = (double)ADP_sutime_ul;
  THR_sutime = (double)THR_sutime_ul;
  GPS_sutime = (double)GPSSYNC.towMsR + ((double)GPSSYNC.towSubMsR * 0.000001);

  tdiff = tGPS - tIMU;
  measurementtimeshift = tdiff.count();
  IMUtoGPS = GPS_sutime - IMU_sutime - measurementtimeshift;

  tdiff = tGPS - tNANO;
  measurementtimeshift = tdiff.count();
  NANOtoGPS = GPS_sutime - NANO_sutime - measurementtimeshift;

  tdiff = tGPS - tADP;
  measurementtimeshift = tdiff.count();
  ADPtoGPS = GPS_sutime - ADP_sutime - measurementtimeshift;

  tdiff = tGPS - tTHR;
  measurementtimeshift = tdiff.count();
  THRtoGPS = GPS_sutime - THR_sutime - measurementtimeshift;

  LOGinfo(14);
}

bool init(void){

  const char * LOGfilech;

  IMUser.flush();
  NANOser.flush();
  ADPser.flush();
  THRser.flush();
  GPSser.flush();

  shmem_ptr_IMU = create_shared_mem(sizeof(IMU), SH_MEM_NAME_IMU);
  shmem_ptr_msg = create_shared_mem(sizeof(binfo.msg), SH_MEM_NAME_MSG);
  shmem_ptr_GPS = create_shared_mem(sizeof(GPS), SH_MEM_NAME_GPS);
  shmem_ptr_ADP = create_shared_mem(sizeof(ADP), SH_MEM_NAME_ADP);
  shmem_ptr_NANO = create_shared_mem(sizeof(NANO), SH_MEM_NAME_NANO);
  shmem_ptr_THR = create_shared_mem(sizeof(THR), SH_MEM_NAME_THR);


  msg_sem = (sem_t*)create_shared_mem(sizeof(sem_t), MSG_SEM_NAME);
  sem_init(msg_sem, 1, 1);

  IMULOGfile = LOGname(IMU_LOG_LOCATION, IMU_LOG_PREFIX);
  LOGfilech = IMULOGfile.c_str();
  if (!access(LOGfilech, F_OK) == 0) {
    LOGinfo(11);
    return false;
  }
  GPSLOGfile = LOGname(GPS_LOG_LOCATION, GPS_LOG_PREFIX);
  LOGfilech = GPSLOGfile.c_str();
  if (!access(LOGfilech, F_OK) == 0) {
    LOGinfo(12);
    return false;
  }
  NANOLOGfile = LOGname(NANO_LOG_LOCATION, NANO_LOG_PREFIX);
  LOGfilech = NANOLOGfile.c_str();
  if (!access(LOGfilech, F_OK) == 0) {
    LOGinfo(17);
    return false;
  }
  ADPLOGfile = LOGname(ADP_LOG_LOCATION, ADP_LOG_PREFIX);
  LOGfilech = ADPLOGfile.c_str();
  if (!access(LOGfilech, F_OK) == 0) {
    LOGinfo(32);
    return false;
  }
  THRLOGfile = LOGname(THR_LOG_LOCATION, THR_LOG_PREFIX);
  LOGfilech = THRLOGfile.c_str();
  if (!access(LOGfilech, F_OK) == 0) {
    LOGinfo(33);
    return false;
  }

  LOGinfo(4);
  if (!gpsinit()) {
    LOGinfo(10);
    return false;
  }
  /*while (!GPSvalidsolution) {
    if (GPSser.available() > 3) {
      GPSparse();
      if ((GPS.flags & 0x01) & 0x01) {
       LOGinfo(5);
       GPSvalidsolution = true;
      }
    }
  }*/
  sync();
  return true;
}

bool cleanup(void){
  IMUser.write("R");
  NANOser.write("R");
  ADPser.write("R");
  THRser.write("R");

  LOGbool = false;

  IMUser.flush();
  NANOser.flush();
  ADPser.flush();
  THRser.flush();
  GPSser.flush();

  shm_unlink(SH_MEM_NAME_IMU);
  shm_unlink(SH_MEM_NAME_GPS);
  shm_unlink(SH_MEM_NAME_MSG);
  shm_unlink(SH_MEM_NAME_ADP);
  shm_unlink(SH_MEM_NAME_NANO);
  shm_unlink(SH_MEM_NAME_THR);
  sem_destroy(msg_sem);

  pinMode(INTERUPT_PIN, INPUT);
  return true;
}

void LOGinfo(int casenmbr){
  ostringstream message;
  switch (casenmbr) {
    case 1: message << "not able to init";
            cout << "SERIALHANDLER: not able to init" << endl;
      break;
    case 2: message << "not able to access LOG file";
            cout << "SERIALHANDLER: not able to access LOG file" << endl;
      break;
    case 3: message << "";
      break;
    case 4: message << "current LOGfiles:" << GPSLOGfile << ",  " << IMULOGfile << ",  " << NANOLOGfile << ",  " << ADPLOGfile << ",  "  << THRLOGfile;
      break;
    case 5: message << "valid GPS Fix, current number of Satellites:" << (int)GPS.numSV;
      break;
    case 6: message << "Received IMU DATA package error (wrong size) IMUtime: " << IMU.IMUtime;
      break;
    case 7: message << "Received IMU MESSAGE package error (wrong size) IMUtime: " << IMU.IMUtime;
      break;
    case 8: message << "Received IMU Header error";
      break;
    case 9: message << "IMU calibrated successfully";
            cout << "IMU calibrated successfully" << endl;
      break;
    case 10: message << "not able to initialize GPS";
      break;
    case 11: message << "not able to create IMU LOG file";
      break;
    case 12: message << "not able to create GPS LOG file";
      break;
    case 13: message << "IMU start signal sent";
      break;
    case 14: message << "Devices Synced GPS UTC tow: " << setprecision(13) << GPS_sutime << ", IMUtime: " << IMU_sutime << " (" << IMUtoGPS << "ms), NANOtime: " << NANO_sutime << " (" << NANOtoGPS << "ms), ADPtime " << ADP_sutime << " (" << ADPtoGPS << "ms), THRtime " << THR_sutime << " (" << THRtoGPS << "ms)";
             cout << "Devices Synced" << endl;
      break;
    case 15: message << "Received System shutdowncall";
      break;
    case 16: message << "Received LOG signal, starting LOGs";
             cout << "SERIALHANDLER: starting LOGs" << endl;
      break;
    case 17: message << "not able to create NANO LOG file";
      break;
    case 18: message << "NANO start signal sent";
      break;
    case 19: message << "Received NANO DATA package error (wrong size) NANOtime: " << NANO.NANOtime;
      break;
    case 20: message << "Received NANO MESSAGE package error (wrong size) NANOtime: " << NANO.NANOtime;
      break;
    case 21: message << "Received NANO Header error";
      break;
    case 22: message << "GPS config send got no response";
      break;
    case 23: message << "cleaned everything up, now terminating process";
      break;
    case 24: message << "Received ADP DATA package error (wrong size) ADPtime: " << ADP.ADPtime;
      break;
    case 25: message << "Received ADP MESSAGE package error (wrong size) ADPtime: " << ADP.ADPtime;
      break;
    case 26: message << "Received ADP Header error";
      break;
    case 27: message << "Received THRUST DATA package error (wrong size) THRtime: " << THR.THRtime;
      break;
    case 28: message << "Received THRUST MESSAGE package error (wrong size) THRtime: " << THR.THRtime;
      break;
    case 29: message << "Received THRUST Header error";
      break;
    case 30: message << "ADP start signal sent";
      break;
    case 31: message << "THRUST start signal sent";
      break;
    case 32: message << "not able to create ADP LOG file";
      break;
    case 33: message << "not able to create THR LOG file";
      break;
  }
  string msg = message.str();
  auto timenow = chrono::system_clock::to_time_t(chrono::high_resolution_clock::now());
  ofstream  info;
  info.open(INFO_LOG, ios::out | ios::app);
  info << "SERIALHANDLER: " << ctime(&timenow) << "   GPS iTOW: "<< GPS.iTOW << ", " << msg << endl;
}
